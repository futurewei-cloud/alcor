= Alcor Security Group Design on Host
Eric Li <sze.li@futurewei.com>, Liguang Xie <lxie@futurewei.com>, Chun-Jen (James) Chung<cchung@futurewei.com>
v0.1, 2020-09-18
:toc: right
:imagesdir: ../../images

NOTE: This document is under development

== Architecture Overview

[source,shell]
------------------------------------------------------------
                  .                                    .
           _______|\                            _______|\
          \  egress \                          \  egress \
          /_______  /                          /_______  /
                  |/     .----------------.            |/
                  '      |  OVS (br-int)  |            '
                         |                |
 VM/Container port <---> |    OpenFlow    | <--> br-tun then NIC HW
                         |     Rules      |
            .            |                |      .
           /|________    '----------------'     /|________
          /  ingress /                         /  ingress /
          \  ________\                         \  ________\
           \|                                   \|
            '                                    '
------------------------------------------------------------

== Requirements

We want to have a design that is:

. Fast provision - end to end port provision including security group < a few 100ms
. Agile update - allow granular update/add/delete one or more security group rule on compute hosts, as opposed to push down all the rules for an update
. Scalable - needs to handle 100,000 ports in a VPC given 1,000,000 machines in a region
. High performance - low latency VM-to-VM communication with port security enabled
. Lean - minimal resource overhead on compute hosts (e.g., bridges, linux device, linux kernel)
. Fast migration - VMs migration should have network blackout time < a few seconds

Note that Security groups are stateful, which means that allowed ingress connections are also allowed to flow out, and vice versa.
Therefore, a connection tracking mechanism is required for its implementation.


== Background: OpenStack Neutron Security Group

OpenStack Neutron makes a significant change on design and implmentation of security group in its Mitaka release which was shipped on April 2016.


=== Before OpenStack Mitaka Release

Here are a few historical challenge before OpenStack Mitaka release on April 2016.

1. Adds a Linux bridge between each VM port and OVS bridge (br-int)
2. Uses Linux devices and linux kernel to support IP Tables implementation
3. Update of single security group rule requires the whole security group to be pushed down to compute hosts,
and requires the IP Tables chain to be recompiled (TBD: review Neutron Agent behavior)
4. This IP Tables implementation cannot be offloaded to hardware, except using a SoC/ARM based NIC which has capability to run the whole Linux OS

[source,shell]
------------------------------------------------------------
   +-------------+                     +---------------+
   |             |                     |               |
   |    VM 1     |                     |     VM 2      |
   |             |                     |               |
   +---+------+--+                     +---+-------+---+
       | eth  |                            |  eth  |
       +--+---+                            +---+---+
          |                                    |
       +--+---+                            +---+---+
       | tap  |                            |  tap  |
 +-----+------+-----+                 +----+-------+-----+
 |                  |                 |                  |
 |   Linux Bridge 1 |                 |   Linux Bridge 2 |
 |                  |                 |                  |
 +-----+------+-----+                 +-----+------+-----+
       | veth |                             | veth |
       +--+---+                             +--+---+
          |                                    |
       +--+---+                             +--+---+
       | veth |                             | veth |
+------+------+-----------------------------+------+---------+
|                                                            |
|                     OVS  Bridge  (br-int)                  |
|                                                            |
+------------------------------------------------------------+
------------------------------------------------------------


=== After OpenStack Mitaka Release

The OpenStack community recognized the challenge of IP Tables implementation for security group rules.
With OVS implementation of connection tracking <<ovs-conntrack>>, many open source solutions including ovs_dpdk_firewall<<intel>> and Dragonflow<<dragonflow-security-group>> start leveraging it for OpenStack.
It is natural for OpenStack Neutron to adopt it.
OpenStack Mitaka introduced official OVS Firewall driver, which addressed many of the issues in the prior releases.
But Alcor can do even better than that.


== Design approach

The Security Group design uses OVS and OpenFlow, building on the latest Neutron OVS firewall rule approach.
It offers the following advantages compared to Neutron:

. On-Host direct connection from VM port to OVS: it doesn't need extra Linux bridge, Linux devices, Linux kernel or IP Tables;
. Direct and simplified communication between Alcor controller to Alcor control agent;
. Delta update: Update of security group rule only require the changed rule to be push down to compute hosts;
. Reduced OVS SG rules: Same security group rule can be shared with any port which follows the same conjunctive rule for remote security group rules;
. Enable scale and performance from the ground up, addressing the biggest pain point on Neutron;
. OpenFlow rules can be offloaded to hardware

Our highlighted improvement is to use only one OpenFlow rule per security group rule, to be shared with all the associated ports on a compute host.
That will promote the scale and performance compared to Neutron.
To support this, we will use openflow conjuction flow<<ovs-fields>>, which is a multiple dimension matching process.
We will mark the ports associated for a particular security group using the first dimension of a conjunctive flow discussed in the later session.

=== Example of Delta Update

Another highlight our design bring is to support minimal goal state message when only one SG rule is updated (in an SG which has 100s of existing rules).
We have added operation_type into each security group rule inside an SG configuration message.
Therefore, only one SG rule is needed in the goal state message without the need to include 100s of existing rules when they have not changed.
The DPM<->ACA schema (securitygroup.proto) already has that.

[source,shell]
------------------------------------------------------------
    message SecurityGroupRule {
        04 bytes - OperationType operation_type = 1;  <---------here
        36 bytes - string security_group_id = 2;
        36 bytes - string id = 3;
        04 bytes - Direction direction = 4;
        04 bytes - EtherType ethertype = 5;
        04 bytes - Protocol protocol = 6;
        04 bytes - uint32 port_range_min = 7;
        04 bytes - uint32 port_range_max = 8;
        18 bytes - string remote_ip_prefix = 9;
        36 bytes - string remote_group_id = 10;
    }
------------------------------------------------------------

The goal state message size reduction is significant.
With Delta update, message size with one security group rule will be around 150 bytes plus outer goal state message and protobuf overhead (around 50 bytes, message total ~200 bytes).
Without Delta update, full message size with 100 security group rules will be 150 bytes times 100 plus outer goal state message and protobuf overhead (around 50 bytes, message total ~15,050 bytes).

=== Remote Security Group Rule Handling

A Security Group rule can refer to a remote security group for both ingress and egress traffic.
When a security group rule is added to security group A, customer can set security group B as the source (for ingress rule) or destination (for egress rule).
This allows ports associated with security group B to access ports that are port of security group A, and vice versa.

[source,shell]
------------------------------------------------------------
+-----------+     +-----------+ 
| Compute   |     | Compute   |
| Node 1    |     | Node 2    |
|           |     |           |
|       OVS + <---| OVS       |
|           |     |           |
| Port 1    |     | Port 2    |
| SG A      |     | SG B      |
+-----------+     +-----------+
------------------------------------------------------------

The default security group has rules that allow associated ports of the default rule to talk to each other.

To support this using the minimal set of OpenFlow rules, we will mark remote ports with its associated security group using conjunctive flows discussed in the next session.
We will update our neighbor configuration schema to include associated security group IDs.
For L3 neighbor, we will leverage on-demand rules so that the OpenFlow rule for the marking is only setup when needed (for egress).
For L2 neighbor, we will go ahead to setup its OpenFlow rules for the marking since it is limited by the subnet size.
We will consider doing on-demand rule for L2 neighbors in the future if needed.

=== Conjunctive flows

With a security group rule that is associated with a remote group ID, ingress rule will need to match on the "n" remote ports IP address (nw_src) and match on the mac addresses (dl_src) for all the ports "m" associated with this security group.
It will result with n * m flows without using conjuctive flows.
The situation is much worse when there are multiple (e.g. 10) security groups associated with a single port.

We will use a conj_id for each combination of (remote SG_id, local port SG_id, ingress/egress, ethertype, flow priority).
This rule is shared between security group rules and used by any flow that matches the same combo.

Conjunctive flows can have 2 or more dimensions.
We will use the first dimension to match the remote ports IP.
We want to merge the rules with when there are multiple IP address if possible.
The second dimension will be used to match the local port mac addresses and also other portion of the rule other than its remote SG_id.
With multiple security group rules associated with a single port, the openflow rules can overlap.
To improve the situation, we want to consolidate and merge the second dimension rules.

Once a traffic flow matches both dimensions, it will be assigned with a conj_id. The conj_id will point to the openflow rules for security group rules processing.


=== Default Security Group

[source,shell]
------------------------------------------------------------
ALLOW: Direction=Egress, Ether Type=IPv4, IP Protocol=Any, Port Range=Any, Remote IP Prefix=0.0.0.0/0
ALLOW: Direction=Egress, Ether Type=IPv6, IP Protocol=Any, Port Range=Any, Remote IP Prefix=::/0
ALLOW: Direction=Ingress, Ether Type=IPv4, IP Protocol=Any, Port Range=Any, Remote SG=default
ALLOW: Direction=Ingress, Ether Type=IPv6, IP Protocol=Any, Port Range=Any, Remote SG=default
------------------------------------------------------------

User can add or delete rules but cannot remove this security group.


=== Customer created Security Group

[source,shell]
------------------------------------------------------------
ALLOW: Direction=Egress, Ether Type=IPv4, IP Protocol=Any, Port Range=Any, Remote IP Prefix=0.0.0.0/0
ALLOW: Direction=Egress, Ether Type=IPv6, IP Protocol=Any, Port Range=Any, Remote IP Prefix=::/0
------------------------------------------------------------

User can add or delete rules or remove this security group.


=== Hidden Security Group Policies

With port security enabled, since all the traffic are blocked by default.
A list of hidden security group rule are allowed to enable basic connectivity, which include allowing for ICMP, ICMP6, ARP, DHCP, DHCPv6, 
SSH (TCP Port:22), RDP (TCP Port:3389) and connection tracking. The rule to allow incoming SSH and RDP can go to default security group.
The system will also enable a rule to only allow traffic coming out from the port has the assigned virtual IP and virtual MAC address to 
disallow IP and MAC spoofing.
See later session for a sample set of openflow rules when a VM port has been added.


== Workflow on Security Group programming

image::security_group_workflow.png[] 


== Implementation Proposal

We will use a list of openflow tables on br-int for security group rule implementation, leveraging Neutron's ovs-firewall driver as a reference.
Most importantly, we need to keep scale and performance in mind.
Therefore, we will:

. keep the minimal number of openflow tables as needed
. leverage the on-demand feature to install security group rules when needed, unknown egress L3 traffic will be sent to OpenFlow controller, which is ACA.
This is similar to L3 on-demand routing algorithm.

In order to support remote SG rules, our neighbor configuration will be updated to include the associated SG_ids for the neighbor port.

=== Recommended Code Changes

This session list the proposed code change location and details:

. update neighbor.proto to add "repeated SecurityGroupId security_group_ids;" to support remote_group rules - futurewei team will do that
. add the ignore logic when PortState::operation_type = INFO inside ACA_Dataplane_OVS::update_port_state_workitem similar to update_subnet_state_workitem
. add a new directory under /src, namely /sg.
. add the implementation files related to security group under the new /src/sg directory, the main file should be named aca_sg_state_handler.cpp, similar to aca_dhcp_state_handler.cpp. Note that we don't have an interface definition like dhcp_programming_if for security group.
. add a new class for the main security group implementation, add default openflow rules in constructor and clean up the openflow rules in destructor. Note that a port can have "port security" enabled (default) or disabled. Therefore, any default openflow rules need to work on both.
. for openflow rule manipulation, use ACA_OVS_Control::get_instance().add_flow/mod_flows/del_flows.
. modify CMakeLists.txt under /src to include new .cpp files.
. modify aca_comm_mgr.cpp - Aca_Comm_Manager::update_goal_state - add a new block for Aca_SG_State_Handler::get_instance().update_sg_states similar to update_dhcp_states.
. update test/gtest/aca_tests.cpp to include a set of unit and functional test cases for security group implementation. We may need to create a docker container, use ovs-docker to connect its port to br-int. Then push down a crafted goal state to configure a new port with a set of security group rules. The last step is to send some traffic to confirm the security group rules are working. See DISABLED_2_ports_ROUTING_test_traffic_one_machine in the same file for reference.

We will need to create/update the corresponding header files accordingly.

=== Integration with Alcor Distributed Router

Alcor Distribute Router was using table 0 to restore gateway mac address from the neighbor host DVR mac. 
With addition of security group implementation, 
we will move that to table 73 (ACCEPT_OR_INGRESS) since those connection is already accepted for ingress pipeline.


== VxLAN-GPE for remote security group

We can consider leveraging VxLAN-GPE to address the scale problem with security group, specially with rules that contain remote group as the amount of ports (and assoicated IPs) on the remote group can be huge.

While the current design still need to work with VxLAN only environment, we will consider leveraging VxLAN-GPE to embed remote security group IDs into ingress packets to apply ingress rule without needing to know all the ports IPs from the remote group before hand.

=== VxLAN-GPE packet with remote security group info

[source,shell]
------------------------------------------------------------
Outer header --- Middle header ----------- Inner packet
VxLAN-GPE ------ NSH with remote SG ID --- IPv4/IPv6 original payload
------------------------------------------------------------

=== OVS egress processing

OVS will need to stamp all packets coming out for a port with the assoicated SG IDs (zero to five).

Each SG ID is about 36 bytes and 5 of them will be about 180 bytes. While VxLAN-GPE + NSH can embed all those information, but 180 bytes is too much data to put into header of every single packet. Therefore, we need to come up with way for more efficient marking and pre-negotiate it between the two end points. 

=== OVS ingress processing

Security group rule with remote group will be coverted to openflow rule to match on SG ID on ingress traffic. Since all VxLAN-GPE ports has all the outgoing traffic stamped with the assoicated SG IDs markings, the one openflow rule will simply look at the matching remote SG ID instead of a potential large scale set of IPs belong to all the ports assoicated with the remote SG.

TBD: need to confirm openflow rule can match on NSH header for our need.


== Sample Openflow rule for Security Group

Below is the full set of OpenFlow rules on br-int when a VM is added in a Microstack setup for reference, quoted text are copied from openstack documentation for better explanation <<ovs-firewall-internal>>:

root@fw0009097:~# microstack.ovs-ofctl dump-flows br-int

=== table 0 (LOCAL_SWITCHING) ===
"contains a low priority rule to continue packets processing in table 60 (TRANSIENT) aka TRANSIENT table. 
table 0 (LOCAL_SWITCHING) is left for use to other features that take precedence over firewall, 
e.g. DVR. The only requirement is that after such a feature is done with its processing, 
it needs to pass packets for processing to the TRANSIENT table."
 cookie=0x18b5fbabf7b6e3f3, duration=22961.497s, table=0, n_packets=0, n_bytes=0, priority=65535,vlan_tci=0x0fff/0x1fff actions=drop
 cookie=0x18b5fbabf7b6e3f3, duration=22961.231s, table=0, n_packets=39, n_bytes=3432, priority=2,in_port="int-br-ex" actions=drop
 cookie=0x18b5fbabf7b6e3f3, duration=22961.499s, table=0, n_packets=185, n_bytes=18157, priority=0 actions=resubmit(,60)

=== table 23,24 (NOT USED) ===
 cookie=0x18b5fbabf7b6e3f3, duration=22961.499s, table=23, n_packets=0, n_bytes=0, priority=0 actions=drop
 cookie=0x18b5fbabf7b6e3f3, duration=22961.497s, table=24, n_packets=0, n_bytes=0, priority=0 actions=drop

=== table 60 - (TRANSIENT) ===
"This TRANSIENT table distinguishes the ingress traffic from the egress traffic and loads into register 5 
a value identifying the port (for egress traffic based on the switch port number, and for ingress traffic 
based on the network id and destination MAC address); register 6 contains a value identifying the network 
(which is also the OVSDB port tag) to isolate connections into separate conntrack zones. For VLAN networks, 
the physical VLAN tag will be used to act as an extra match rule to do such identifying work as well."
 cookie=0x18b5fbabf7b6e3f3, duration=1156.933s, table=60, n_packets=114, n_bytes=10202, priority=100,in_port="tap0308ac0c-28" actions=load:0x3->NXM_NX_REG5[],load:0x1->NXM_NX_REG6[],resubmit(,71)
 cookie=0x18b5fbabf7b6e3f3, duration=1156.933s, table=60, n_packets=70, n_bytes=7913, priority=90,dl_vlan=1,dl_dst=fa:16:3e:38:c6:87 actions=load:0x3->NXM_NX_REG5[],load:0x1->NXM_NX_REG6[],strip_vlan,resubmit(,81)
 cookie=0x18b5fbabf7b6e3f3, duration=22961.499s, table=60, n_packets=1, n_bytes=42, priority=3 actions=NORMAL

=== table 71 (BASE_EGRESS) ===
"table 71 (BASE_EGRESS) implements ARP spoofing protection, IP spoofing protection, allows traffic related 
to IP address allocations (dhcp, dhcpv6, slaac, ndp) for egress traffic, and allows ARP replies. 
Also identifies not tracked connections which are processed later with information obtained from conntrack. 
Notice the zone=NXM_NX_REG6[0..15] in actions when obtaining information from conntrack. It says every port has
 its own conntrack zone defined by the value in register 6 (OVSDB port tag identifying the network). 
 It’s there to avoid accepting established traffic that belongs to different port with same conntrack parameters.

The very first rule in table 71 (BASE_EGRESS) is a rule removing conntrack information for a use-case where 
Neutron logical port is placed directly to the hypervisor. In such case kernel does conntrack lookup before 
packet reaches Open vSwitch bridge. Tracked packets are sent back for processing by the same table after 
conntrack information is cleared."
 cookie=0x18b5fbabf7b6e3f3, duration=22960.796s, table=71, n_packets=0, n_bytes=0, priority=110,ct_state=+trk actions=ct_clear,resubmit(,71)

"Rules below allow ICMPv6 traffic for multicast listeners, neighbour solicitation and neighbour advertisement."
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=71, n_packets=0, n_bytes=0, priority=95,icmp6,reg5=0x3,in_port="tap0308ac0c-28",icmp_type=130 actions=resubmit(,94)
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=71, n_packets=3, n_bytes=210, priority=95,icmp6,reg5=0x3,in_port="tap0308ac0c-28",icmp_type=133 actions=resubmit(,94)
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=71, n_packets=1, n_bytes=78, priority=95,icmp6,reg5=0x3,in_port="tap0308ac0c-28",icmp_type=135 actions=resubmit(,94)
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=71, n_packets=0, n_bytes=0, priority=95,icmp6,reg5=0x3,in_port="tap0308ac0c-28",icmp_type=136 actions=resubmit(,94)
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=71, n_packets=0, n_bytes=0, priority=70,icmp6,reg5=0x3,in_port="tap0308ac0c-28",icmp_type=134 actions=resubmit(,93)

"Following rules implement ARP spoofing protection"
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=71, n_packets=3, n_bytes=126, priority=95,arp,reg5=0x3,in_port="tap0308ac0c-28",dl_src=fa:16:3e:38:c6:87,arp_spa=192.168.222.248 actions=resubmit(,94)

"DHCP and DHCPv6 traffic is allowed to instance but DHCP servers are blocked on instances."
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=71, n_packets=2, n_bytes=686, priority=80,udp,reg5=0x3,in_port="tap0308ac0c-28",tp_src=68,tp_dst=67 actions=resubmit(,73)
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=71, n_packets=0, n_bytes=0, priority=80,udp6,reg5=0x3,in_port="tap0308ac0c-28",tp_src=546,tp_dst=547 actions=resubmit(,73)
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=71, n_packets=0, n_bytes=0, priority=70,udp,reg5=0x3,in_port="tap0308ac0c-28",tp_src=67,tp_dst=68 actions=resubmit(,93)
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=71, n_packets=0, n_bytes=0, priority=70,udp6,reg5=0x3,in_port="tap0308ac0c-28",tp_src=547,tp_dst=546 actions=resubmit(,93)

"Flowing rules obtain conntrack information for valid IP and MAC address combinations. All other packets are dropped."
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=71, n_packets=101, n_bytes=8742, priority=65,ip,reg5=0x3,in_port="tap0308ac0c-28",dl_src=fa:16:3e:38:c6:87,nw_src=192.168.222.248 actions=ct(table=72,zone=NXM_NX_REG6[0..15])
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=71, n_packets=2, n_bytes=180, priority=65,ipv6,reg5=0x3,in_port="tap0308ac0c-28",dl_src=fa:16:3e:38:c6:87,ipv6_src=fe80::f816:3eff:fe38:c687 actions=ct(table=72,zone=NXM_NX_REG6[0..15])
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=71, n_packets=2, n_bytes=180, priority=10,reg5=0x3,in_port="tap0308ac0c-28" actions=ct_clear,resubmit(,93)
 cookie=0x18b5fbabf7b6e3f3, duration=22960.848s, table=71, n_packets=0, n_bytes=0, priority=0 actions=drop

=== table 72 (RULES_EGRESS) ===
"table 72 (RULES_EGRESS) accepts only established or related connections, and implements rules defined by 
security groups. As this egress connection might also be an ingress connection for some other port, 
it’s not switched yet but eventually processed by the ingress pipeline."
Following rules allows all egress IPv4 and IPv6 traffic, as port of default security group rule.
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=72, n_packets=0, n_bytes=0, priority=74,ct_state=+est-rel-rpl,ipv6,reg5=0x3 actions=resubmit(,73)
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=72, n_packets=80, n_bytes=7120, priority=74,ct_state=+est-rel-rpl,ip,reg5=0x3 actions=resubmit(,73)
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=72, n_packets=0, n_bytes=0, priority=74,ct_state=+new-est,ipv6,reg5=0x3 actions=resubmit(,73)
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=72, n_packets=21, n_bytes=1622, priority=74,ct_state=+new-est,ip,reg5=0x3 actions=resubmit(,73)

invalid (+inv) packets sends to table 93 (DROPPED_TRAFFIC) to drop
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=72, n_packets=2, n_bytes=180, priority=50,ct_state=+inv+trk actions=resubmit(,93)

"Important on the flows below is the ct_mark=0x1. Flows that were marked as not existing anymore by rule 
introduced later will value this value. Those are typically connections that were allowed by some security 
group rule and the rule was removed."
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=72, n_packets=0, n_bytes=0, priority=50,ct_mark=0x1,reg5=0x3 actions=resubmit(,93)

"All other connections that are not marked and are established or related are allowed."
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=72, n_packets=0, n_bytes=0, priority=50,ct_state=+est-rel+rpl,ct_zone=1,ct_mark=0,reg5=0x3 actions=resubmit(,94)
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=72, n_packets=0, n_bytes=0, priority=50,ct_state=-new-est+rel-inv,ct_zone=1,ct_mark=0,reg5=0x3 actions=resubmit(,94)

"In the following, flows are marked established connections that weren’t matched in the previous flows, 
which means they don’t have accepting security group rule anymore."
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=72, n_packets=0, n_bytes=0, priority=40,ct_state=-est,reg5=0x3 actions=resubmit(,93)
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=72, n_packets=0, n_bytes=0, priority=40,ct_state=+est,ip,reg5=0x3 actions=ct(commit,zone=NXM_NX_REG6[0..15],exec(load:0x1->NXM_NX_CT_MARK[]))
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=72, n_packets=0, n_bytes=0, priority=40,ct_state=+est,ipv6,reg5=0x3 actions=ct(commit,zone=NXM_NX_REG6[0..15],exec(load:0x1->NXM_NX_CT_MARK[]))
 cookie=0x18b5fbabf7b6e3f3, duration=22960.837s, table=72, n_packets=0, n_bytes=0, priority=0 actions=drop

=== table 73 (ACCEPT_OR_INGRESS) ===
"In following table 73 (ACCEPT_OR_INGRESS) are all detected ingress connections sent to ingress pipeline. 
Since the connection was already accepted by egress pipeline, all remaining egress connections are sent to 
normal flood’n’learn switching in table 94 (ACCEPTED_EGRESS_TRAFFIC_NORMAL)."
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=73, n_packets=0, n_bytes=0, priority=100,reg6=0x1,dl_dst=fa:16:3e:38:c6:87 actions=load:0x3->NXM_NX_REG5[],resubmit(,81)
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=73, n_packets=21, n_bytes=1622, priority=90,ct_state=+new-est,ip,reg5=0x3 actions=ct(commit,zone=NXM_NX_REG6[0..15]),resubmit(,91)
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=73, n_packets=0, n_bytes=0, priority=90,ct_state=+new-est,ipv6,reg5=0x3 actions=ct(commit,zone=NXM_NX_REG6[0..15]),resubmit(,91)
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=73, n_packets=82, n_bytes=7806, priority=80,reg5=0x3 actions=resubmit(,94)
 cookie=0x18b5fbabf7b6e3f3, duration=22960.828s, table=73, n_packets=0, n_bytes=0, priority=0 actions=drop

=== table 81 (BASE_INGRESS) ===
"table 81 (BASE_INGRESS) is similar to table 71 (BASE_EGRESS), allows basic ingress traffic for obtaining 
IP address and ARP queries. Note that vlan tag must be removed by adding strip_vlan to actions list, prior 
to injecting packet directly to port. Not tracked packets are sent to obtain conntrack information."
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=81, n_packets=3, n_bytes=126, priority=100,arp,reg5=0x3 actions=output:"tap0308ac0c-28"
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=81, n_packets=0, n_bytes=0, priority=100,icmp6,reg5=0x3,icmp_type=130 actions=output:"tap0308ac0c-28"
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=81, n_packets=0, n_bytes=0, priority=100,icmp6,reg5=0x3,icmp_type=135 actions=output:"tap0308ac0c-28"
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=81, n_packets=0, n_bytes=0, priority=100,icmp6,reg5=0x3,icmp_type=136 actions=output:"tap0308ac0c-28"
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=81, n_packets=2, n_bytes=762, priority=95,udp,reg5=0x3,tp_src=67,tp_dst=68 actions=output:"tap0308ac0c-28"
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=81, n_packets=0, n_bytes=0, priority=95,udp6,reg5=0x3,tp_src=547,tp_dst=546 actions=output:"tap0308ac0c-28"
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=81, n_packets=65, n_bytes=7025, priority=90,ct_state=-trk,ip,reg5=0x3 actions=ct(table=82,zone=NXM_NX_REG6[0..15])
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=81, n_packets=0, n_bytes=0, priority=90,ct_state=-trk,ipv6,reg5=0x3 actions=ct(table=82,zone=NXM_NX_REG6[0..15])
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=81, n_packets=0, n_bytes=0, priority=80,ct_state=+trk,reg5=0x3 actions=resubmit(,82)
 cookie=0x18b5fbabf7b6e3f3, duration=22960.818s, table=81, n_packets=0, n_bytes=0, priority=0 actions=drop

=== table 82 (RULES_INGRESS) ===
"Similarly to table 72 (RULES_EGRESS), table 82 (RULES_INGRESS) accepts established and related connections. 
In this case we allow all traffic coming from default security group. The first four flows match on the IP 
addresses, and the next two flows match on the ICMP protocol. These six flows define conjunction flows, 
and the next two define actions for them."
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=82, n_packets=0, n_bytes=0, priority=77,ct_state=+est-rel-rpl,tcp,reg5=0x3,tp_dst=22 actions=output:"tap0308ac0c-28"
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=82, n_packets=0, n_bytes=0, priority=77,ct_state=+new-est,tcp,reg5=0x3,tp_dst=22 actions=ct(commit,zone=NXM_NX_REG6[0..15]),output:"tap0308ac0c-28",resubmit(,92)
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=82, n_packets=0, n_bytes=0, priority=75,ct_state=+est-rel-rpl,icmp,reg5=0x3 actions=output:"tap0308ac0c-28"
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=82, n_packets=0, n_bytes=0, priority=75,ct_state=+new-est,icmp,reg5=0x3 actions=ct(commit,zone=NXM_NX_REG6[0..15]),output:"tap0308ac0c-28",resubmit(,92)

conjunction rules in action:
 cookie=0x18b5fbabf7b6e3f3, duration=1158.885s, table=82, n_packets=0, n_bytes=0, priority=70,ct_state=+est-rel-rpl,ip,reg6=0x1,nw_src=192.168.222.248 actions=conjunction(8,1/2)
 cookie=0x18b5fbabf7b6e3f3, duration=1158.885s, table=82, n_packets=0, n_bytes=0, priority=70,ct_state=+new-est,ip,reg6=0x1,nw_src=192.168.222.248 actions=conjunction(9,1/2)
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=82, n_packets=0, n_bytes=0, priority=70,ct_state=+est-rel-rpl,ip,reg5=0x3 actions=conjunction(8,2/2)
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=82, n_packets=0, n_bytes=0, priority=70,ct_state=+est-rel-rpl,ipv6,reg5=0x3 actions=conjunction(16,2/2)
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=82, n_packets=0, n_bytes=0, priority=70,ct_state=+new-est,ip,reg5=0x3 actions=conjunction(9,2/2)
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=82, n_packets=0, n_bytes=0, priority=70,ct_state=+new-est,ipv6,reg5=0x3 actions=conjunction(17,2/2)

"The remaining is a L4 protocol agnostic rule."
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=82, n_packets=0, n_bytes=0, priority=70,conj_id=8,ct_state=+est-rel-rpl,ip,reg5=0x3 actions=load:0x8->NXM_NX_REG7[],output:"tap0308ac0c-28"
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=82, n_packets=0, n_bytes=0, priority=70,conj_id=16,ct_state=+est-rel-rpl,ipv6,reg5=0x3 actions=load:0x10->NXM_NX_REG7[],output:"tap0308ac0c-28"
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=82, n_packets=0, n_bytes=0, priority=70,conj_id=9,ct_state=+new-est,ip,reg5=0x3 actions=load:0x9->NXM_NX_REG7[],ct(commit,zone=NXM_NX_REG6[0..15]),output:"tap0308ac0c-28",resubmit(,92)
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=82, n_packets=0, n_bytes=0, priority=70,conj_id=17,ct_state=+new-est,ipv6,reg5=0x3 actions=load:0x11->NXM_NX_REG7[],ct(commit,zone=NXM_NX_REG6[0..15]),output:"tap0308ac0c-28",resubmit(,92)

invalid (+inv) packets or ct_mark=0x1 (removed rules) sends to table 93 (DROPPED_TRAFFIC) to drop
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=82, n_packets=0, n_bytes=0, priority=50,ct_state=+inv+trk actions=resubmit(,93)
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=82, n_packets=0, n_bytes=0, priority=50,ct_mark=0x1,reg5=0x3 actions=resubmit(,93)

"The mechanism for dropping connections that are not allowed anymore is the same as in table 72 (RULES_EGRESS)."
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=82, n_packets=65, n_bytes=7025, priority=50,ct_state=+est-rel+rpl,ct_zone=1,ct_mark=0,reg5=0x3 actions=output:"tap0308ac0c-28"
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=82, n_packets=0, n_bytes=0, priority=50,ct_state=-new-est+rel-inv,ct_zone=1,ct_mark=0,reg5=0x3 actions=output:"tap0308ac0c-28"
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=82, n_packets=0, n_bytes=0, priority=40,ct_state=-est,reg5=0x3 actions=resubmit(,93)
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=82, n_packets=0, n_bytes=0, priority=40,ct_state=+est,ip,reg5=0x3 actions=ct(commit,zone=NXM_NX_REG6[0..15],exec(load:0x1->NXM_NX_CT_MARK[]))
 cookie=0x18b5fbabf7b6e3f3, duration=1156.934s, table=82, n_packets=0, n_bytes=0, priority=40,ct_state=+est,ipv6,reg5=0x3 actions=ct(commit,zone=NXM_NX_REG6[0..15],exec(load:0x1->NXM_NX_CT_MARK[]))
 cookie=0x18b5fbabf7b6e3f3, duration=22960.808s, table=82, n_packets=0, n_bytes=0, priority=0 actions=drop

=== table 91 (ACCEPTED_EGRESS_TRAFFIC) ===
"Packets are sent to table 91 (ACCEPTED_EGRESS_TRAFFIC) and table 94 (ACCEPTED_EGRESS_TRAFFIC_NORMAL) when 
they are considered accepted by the egress pipeline, and they will be processed so that they are forwarded 
to their destination by being submitted to a NORMAL action, that results in Ethernet flood/learn processing.

Two tables are used to differentiate between the first packets of a connection and the following packets. 
This was introduced for performance reasons to allow the logging extension to only log the first packets 
of a connection. Only the first accepted packet of each connection session will go to table 91 (ACCEPTED_EGRESS_TRAFFIC) 
and the following ones will go to table 94 (ACCEPTED_EGRESS_TRAFFIC_NORMAL).

Note that table 91 (ACCEPTED_EGRESS_TRAFFIC) merely resubmits to table 94 (ACCEPTED_EGRESS_TRAFFIC_NORMAL) 
that contains the actual NORMAL action; this allows to have a single place where the NORMAL action can be 
overridden by other components (currently used by networking-bagpipe driver for networking-bgpvpn)."
 cookie=0x18b5fbabf7b6e3f3, duration=22960.776s, table=91, n_packets=21, n_bytes=1622, priority=1 actions=resubmit(,94)

=== table 92 (ACCEPTED_INGRESS_TRAFFIC) ===
"The first packet of each connection accepted by the ingress pipeline is sent to table 92 (ACCEPTED_INGRESS_TRAFFIC). 
The default action in this table is DROP because at this point the packets have already been delivered to their 
destination port. This integration point is essentially provided for the logging extension."
 cookie=0x18b5fbabf7b6e3f3, duration=22960.766s, table=92, n_packets=0, n_bytes=0, priority=0 actions=drop

=== table 93 (DROPPED_TRAFFIC) ===
"Packets are sent to table 93 (DROPPED_TRAFFIC) if processing by the ingress filtering concluded that they should be dropped."
 cookie=0x18b5fbabf7b6e3f3, duration=22960.756s, table=93, n_packets=4, n_bytes=360, priority=0 actions=drop

=== table 94 (ACCEPTED_EGRESS_TRAFFIC_NORMAL)  ===
 cookie=0x18b5fbabf7b6e3f3, duration=22960.785s, table=94, n_packets=110, n_bytes=9842, priority=1 actions=NORMAL


== Pending Items

. Can we rely on a centralized gateway service to check for security group rules?
Is it a bad idea due to security concern and waste of bandwidth as all kinds of traffic, some of which can be dropped previously at the compute hosts, will be sent out from compute hosts to gateway)?

. Can we only download the needed security group rule from Alcor Controller into compute hosts when it is needed?
What is the latency requirement if we enable "on-demand" programming?

. What happen if a host is crashed, do we ask the Alcor Controller for the whole set of configuration upon restart?


[bibliography]
== References

- [[[ovs-conntrack,1]]] https://ovs-istokes.readthedocs.io/en/latest/tutorials/ovs-conntrack.html
- [[[intel,2]]] https://software.intel.com/content/www/us/en/develop/articles/implementing-an-openstack-security-group-firewall-driver-using-ovs-learn-actions.html
- [[[dragonflow-security-group,3]]] https://galsagie.github.io/2015/12/28/dragonflow-security-groups/
- [[[ovs-fields,4]]] https://www.man7.org/linux/man-pages/man7/ovs-fields.7.html
- [[[ovs-openflow,5]]] https://object-storage-ca-ymq-1.vexxhost.net/swift/v1/6e4619c416ff4bd19e1c087f27a43eea/www-assets-prod/presentation-media/Austin-Summit-SG-firewall-Presentation-v2.3.pdf
- [[[openstack-implementation,6]]]  https://github.com/openstack/neutron/commit/ef29f7eb9a2a37133eacdb7f019b48ec3f9a42c3 
- [[[neutron-security-group,7]]] https://docs.openstack.org/nova/train/admin/security-groups.html
- [[[dragonflow-conj,8]]] https://docs.openstack.org/dragonflow/ocata/specs/security_groups.html
- [[[ovs-firewall-internal,9]]] https://docs.openstack.org/neutron/train/contributor/internals/openvswitch_firewall.html