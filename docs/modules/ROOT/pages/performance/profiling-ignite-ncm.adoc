= Profiling Ignite through AlcorController

Prasad Kommoju <pkommoju@futurewei.com>, Zhaoxi Zhu <zzhu@futurewei.com>
2021-06-15

:imagesdir: ../../images

== Machine Configuration
[source]
|===
| Machine| Process| CPUs | Total Memory
|10.213.43.161| NCM|40| 192GB
|10.213.43.161| TC|40| 192GB
|10.213.43.90| ACA node 1| 24| 128GB
|10.213.43.94| ACA node 2| 24| 128GB
|10.213.43.163| Ignite node 1| 40|192GB
|10.213.43.164| Ignite node 2| 40| 192GB
|===

All machines have only one disk on line and it appears to be a spinning disk. Having one disk to write both Ignite WAL, and DB puts 

== NCM and Ignite JVM options
[source]
 -Djava.net.preferIPv4Stack=true \
            -Xms40G \
            -XX:MaxMetaspaceSize=1G \
            -Xmx40G \
            -XX:NewSize=512m \
            -XX:SurvivorRatio=6 \
            -XX:+AlwaysPreTouch \
            -XX:+UseG1GC \
            -XX:MaxGCPauseMillis=2000 \
            -XX:GCTimeRatio=4 \
            -XX:InitiatingHeapOccupancyPercent=30 \
            -XX:G1HeapRegionSize=33554432 \
            -XX:ParallelGCThreads=8 \
            -XX:ConcGCThreads=8 \
            -XX:G1HeapWastePercent=10 \
            -XX:+UseTLAB \
            -XX:+ScavengeBeforeFullGC \
            -XX:+DisableExplicitGC \
            -XX:+PrintGCDetails \
            -XX:+FlightRecorder \
            -XX:+UnlockDiagnosticVMOptions \
            -XX:+DebugNonSafepoints \
            -Xloggc:/tmp/<service-specific-tag>-gc-log.txt

== Ignite configuration
[source]
      <property name="dataStorageConfiguration">
         <bean class="org.apache.ignite.configuration.DataStorageConfiguration">
            <!-- set the size of wal segments to 256MB -->
            <property name="walSegmentSize" value="#{256 * 1024 * 1024}"/>
            <property name="systemRegionInitialSize" value="#{2L * 1024 * 1024 * 1024}"/>
            <property name="systemRegionMaxSize" value="#{2L * 1024 * 1024 * 1024}"/>
            <property name="defaultDataRegionConfiguration">
               <bean class="org.apache.ignite.configuration.DataRegionConfiguration">
                <property name="persistenceEnabled" value="true"/>
                <property name="metricsEnabled" value="true"/>
                <property name="initialSize" value="#{32L * 1024 * 1024 * 1024}"/>
                <property name="maxSize" value="#{32L * 1024 * 1024 * 1024}"/>
               </bean>
            </property>
         </bean>
      </property>
      
      <property name="cacheConfiguration">
        <list>
             <bean class="org.apache.ignite.configuration.CacheConfiguration">
                <!-- Set the cache name. -->
                <property name="name" value="com.futurewei.alcor.netwconfigmanager.entity.ResourceMeta"/>
                <!-- Set the cache mode. -->
                <property name="atomicityMode" value="TRANSACTIONAL"/>
                <!-- Other cache parameters. -->
                <property name="cacheMode" value="PARTITIONED"/>
             </bean>

             <bean class="org.apache.ignite.configuration.CacheConfiguration">
                <!-- Set the cache name. -->
                 <property name="name" value="com.futurewei.alcor.netwconfigmanager.entity.VpcResourceMeta"/>
                <!-- Set the cache mode. -->
                <property name="atomicityMode" value="TRANSACTIONAL"/>
                <!-- Other cache parameters. -->
                <property name="cacheMode" value="PARTITIONED"/>
             </bean>

             <bean class="org.apache.ignite.configuration.CacheConfiguration">
                <!-- Set the cache name. -->
                 <property name="name" value="java.lang.Object"/>
                <!-- Set the cache mode. -->
                <property name="atomicityMode" value="TRANSACTIONAL"/>
                <!-- Other cache parameters. -->
                <property name="cacheMode" value="PARTITIONED"/>
             </bean>
        </list>
    </property>



== Observations

=== Logs from the runs
* xref:ncm-21-06-21-03.log[NCM log file]
* xref:ncm-21-06-21-03.html[NCM profile data (using async-profiler)]
* xref:run-200p-run-01.nps[Ignite VisualVM profile snapshot]
* xref:syslog-aca-1.log[ACA log from mode 1]
* xref:syslog-aca-2.log[ACA log from mode 2]
* xref:ignite-caches.txt[Ignite caches]
* xref:tc-21-06-21-01.log[Test Controller log]


=== Timing analysis.
The following times are from creating two goal states with 100 through 2200 ports each and two with 5000 ports each. TestController was modified to not send GS to ACA or trigger on demand request to excercise just NCM to Ignite latency.

|====
| Log line | Method| Analysis

|finished getting resource meta from cache| hostResourceMetadataCache.getResourceMeta| Direct call to Ignite. Time ranges from 1 to 29 ms. 29 x 1ms, 25 x 2ms, 14 x 3, 8 x 4ms, 1 x 6ms, 11ms, and 29ms. The time looks reasonably fast.

|existing is null, finished adding resource meta from cache|hostResourceMetadataCache.addResourceMeta| Direct call to Ignite. Two GS were used and this component of the time is 10ms and 49ms. 49ms comes from 10.213.43.94, which seems to be slower for some reason.

|existing is NOT null, finished adding resource meta from cache| Direct callto Ignite.| Updates exisitng resource. Times range from 0 to 7ms.With 78 times under 5ms and 5ms and 7ms for two requests, these times also appear to be reasonable.

|finished processing goalState| processXYZstates| Indirect calls to Ignite. Eight different caches are written to, each through a loop. As number of ports increase, so does this time. It ranges fro 61ms to 5600ms. This time may be optimized by using batch insert (putAll) interface.

| finished populating vpc resource cache| populateVpcResourceCache| Two calls to Ignite from a loop. Times range from 13,293ms through 468,639ms. This time includes all of the above. This is also very high and batch insert (putAll) could reduce it.

|retrieved resource meta for vni| vpcResourceCache.getResourceMeta| Time ranges from 1ms to 56,805. 105 out of 175 calls take less than 100ms. This time may also be reduced by putAll.

|added resource metadata for vpc with vni|vpcResourceCache.addResourceMeta| Time ranges from 1ms to 383ms. This time may also be reduced by putAll.
|====


|====
| Number of ports in the GoalState|Time to persist ( seconds)

|100|     13

|200|     27

|300|     42

|400|     54

|500|     67

|600|     81

|700|     94

|800|    109

|900|    122

|1000|   137

|1100|   310

|1200|   341

|1300|   360

|1400|   390

|1500|   420

|1600|   441

|1700|   470

|1800|   491

|1900|   520

|2000|   540

|2100|   571

|2200|   611
|====



== Latency Plot


image::ncm-inginte-gs-latency.png

== Update on July 5, 2021
This update contains all the experiments and observations collected over the last couple of weeks.
One optimization to NCM is to call getResorceMeta in populateVpcResourceCache outside the loops once. Another change was to collect per call timing of getResorceMeta by calling it in a loop.
The data collected include YourKit profiler snapshots of NCM and Ignite and relevant logfiles.

* xref:Ignite-CPU-hot-spots-200p.html[hotspots in Ignite profile snapshot]
* xref:ncm-CPU-hot-spots-200p.html[hotspots in NCM profile snapshot]
* xref:networkconfigmanager-0.1.0-SNAPSHOT-2021-07-05_01.snapshot[NCM full CPU profiler snapshot, need YourKit to visualize it]
* xref:ignite-ALL-UNNAMED-2021-07-05_1.snapshot[Ignite full CPU profiler snapshot, need YourKit to visualize it]
* xref:getvni-2p.txt[Timings of calling vpcResourceCache.getResourceMeta 1000 times for a 2 port GS]
* xref:ncm-2021-07-02-pvrco-02-2p.log[NCM log of 2 port goal state put/get]
* xref:ncm-2021-07-02-pvrco-2p-prof.log[Same as above but NCM under profiler]
* xref:getvni-100p.txt[Timings of calling vpcResourceCache.getResourceMeta 1000 times for a 100 port GS]
* xref:ncm-2021-07-02-pvrco-02-100p.log[NCM log of 200 port goal state put/get]
* xref:ncm-2021-07-05-pvrco-100p-prof.log[Same as above but NCM under profiler]
* xref:getvni-freq.txt[Histogram of getResourceMeta latencies]


The profiler shows that NCM had 28 GC pauses with average pause lasting 12ms to maximum of 44ms. Ignite had 6 GC pauses averaging 46ms per pause and maximum of 70ms.

Most of the latency is inside the Ignite client which is part of NCM and Ignite server itself. Some of the latency is the network, which will be compurted in next iteration.

One task is to breakdown the total latency into three components: NCM proper, network, and Ignite proper.
Another experiment is to move VpcResourceCache into JVM heap to measure the effect of serialization and deserialization.

== Conclusions
* Use PutAll interface whenever possible, especailly if cache get and put are from inside a lopp which iterates over a large collection.

* Do as much work as possible outside Ignite transaction and loops.

* Try to parallelize DB work.

* Setup a performance test and run it periodically to monitor the DB performance changes as new code gets added.

* Approach Gridgain when there is enough data to show the source of latency to be Ignite.

